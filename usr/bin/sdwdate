#!/bin/bash

## This file is part of Whonix.
## Copyright (C) 2012 - 2014 Patrick Schleizer <adrelanos@riseup.net>
## See the file COPYING for copying conditions.

## CREDITS
## - sdwdate is a rewrite of tails_htp in bash
## - defaults taken from tails_htp
## - options inspired by tails_htp
## - log file layout inspired by tails_htp
## - sclockadj has been written by Jason Ayala (Jason@JasonAyala.com)

## TODO:
## - implement --user
## - refactoring, having "_curl_" in variable names is not that good, because
##   support for tlsdate has been added as well

#set -x
set -o pipefail

SCRIPTNAME="$(basename "$BASH_SOURCE")"
ownpid="$$"
ID="$(cat "/proc/sys/kernel/random/uuid")"
SDW_MODE="startup"

sdwdate_usage() {
   trap "sdwdate_error_handler" ERR

   echo "\
$SCRIPTNAME [-aDdlpqTux] [long options...]
        -d --debug                            debug
        --help                                print usage message and exit
        -q --quiet                            quiet
        -x --dont_set_date                    do not set the time (only show)
        --no-move-forward                     do not move the time forward
        --no-move-backwards                   do not move the time backwards
        --systohc                             update hardware clock
        -a --user_agent                       http user agent to use
        -l --log_file                         log to this file rather than to STDOUT
        -D --done_file                        create this file after one cycle of sdwdate
        -T --success_file                     create this file after setting time successfully
        --pool_one                            distrusted hostnames
        --pool_two                            distrusted hostnames
        --pool_three                          distrusted hostnames
        --allowed_per_pool_failure_ratio      ratio (0.0-1.0) of allowed per-pool failure
        -p --proxy                            what to pass to curl's --socks5-hostname
        -i --interval                         continuously run every x minutes
        --mininterval                         wait minimum between intervals
        -r --randomize                        randomize interval
        -n --noconfig                         ignore /etc/sdwdate.d/ config folder
        --parsecmd_only_on_startup            parse command line arguments only on startup
        -w --dispatchpre                      exec before run
        -y --dispatchprerequisite             check before run
        -x --dispatchpostsuccess              exec after successful run
        -z --dispatchpostfailure              exec after unsuccessful run
        -m --dispatchposterror                exec when an error is caught
        --dispatch_pre_one                    exec before run of curl
        --dispatch_post_one                   exec after run of curl
        --dispatch_pre_two                    exec before run of curl
        --dispatch_post_two                   exec after run of curl
        --dispatch_pre_three                  exec before first run of curl
        --dispatch_post_three                 exec after run of curl
        --nodonefileonerror
        --noexitonerror
        --time-fetching-method                curl or tlsdate
        --tlsdate-extra-options               tlsdate extra options"

#       -u --user                             userid to run as
}

sdwdate_defaults() {
   trap "sdwdate_error_handler" ERR

   if [ "$CURL_VERBOSE" = "" ]; then
      CURL_VERBOSE="--silent"
   fi

   if [ "$DEBUG" = "" ]; then
      DEBUG="0"
   fi

   if [ "$USER" = "" ]; then
      USER=""
   fi

   if [ "$DONT_SET_DATE" = "" ]; then
      DONT_SET_DATE="0"
   fi

   if [ "$NO_MOVE_FORWARD" = "" ]; then
      NO_MOVE_FORWARD=1
   fi

   if [ "$NO_MOVE_BACKWARDS" = "" ]; then
      NO_MOVE_BACKWARDS=1
   fi

   if [ "$SYSTOHC" = "" ]; then
      SYSTOHC=0
      SDWDATE_SCLOCKADJ_SYSTOHC="--nosystohc"
   fi

   if [ "$LOG_FILE" = "" ]; then
      LOG_FILE=~/.sdwdate/log
   fi

   if [ "$DONE_FILE" = "" ]; then
      DONE_FILE=~/.sdwdate/done
   fi

   if [ "$SUCCESS_FILE" = "" ]; then
      SUCCESS_FILE=~/.sdwdate/success
   fi

   if [ "$ALLOWED_PER_POOL_FAILURE_RATIO" = "" ]; then
      ALLOWED_PER_POOL_FAILURE_RATIO="0.34"
   fi

   if [ "$TEMP_DIR" = "" ]; then
      TEMP_DIR="$(mktemp --directory)"
   fi
   ## Export so plugins run by sdwdate can use it.
   export TEMP_DIR

   if [ "$PROXY" = "" ]; then
      PROXY=""
   fi

   if [ "$CURL_PROXY" = "" ]; then
      CURL_PROXY=""
   fi

   if [ "$INTERVAL" = "" ]; then
      INTERVAL=""
   fi

   if [ "$MIN_INTERVAL" = "" ]; then
      MIN_INTERVAL="10"
   fi

   if [ "$NOCONFIG" = "" ]; then
      NOCONFIG=""
   fi

   if [ "$PARSE_CMD_ONLY_ON_STARTUP" = "" ]; then
      PARSE_CMD_ONLY_ON_STARTUP=""
   fi

   if [ "$RANDOMIZE" = "" ]; then
      RANDOMIZE=""
   fi

   if [ "$DISPATCH_PREREQUISITE" = "" ]; then
      DISPATCH_PREREQUISITE="true"
   fi

   if [ "$DISPATCH_POST_ERROR" = "" ]; then
      DISPATCH_POST_ERROR="exit 1"
   fi

   if [ "$SDW_TOUCH_DONE_FILE_ON_ERROR" = "" ]; then
      SDW_TOUCH_DONE_FILE_ON_ERROR="1"
   fi

   if [ "$SDW_EXIT_ON_ERROR" = "" ]; then
      SDW_EXIT_ON_ERROR="1"
   fi

   if [ "$DISPATCH_PRE" = "" ]; then
      DISPATCH_PRE="true"
   fi

   if [ "$DISPATCH_POST_SUCCESS" = "" ]; then
      DISPATCH_POST_SUCCESS="true"
   fi

   if [ "$DISPATCH_POST_FAILURE" = "" ]; then
      DISPATCH_POST_FAILURE="true"
   fi

   if [ "$HTTP_USER_AGENT" = "" ]; then
      HTTP_USER_AGENT=""
      #HTTP_USER_AGENT="$(/usr/bin/getTorbuttonUserAgent)"
      #HTTP_USER_AGENT="Mozilla/5.0 (Windows NT 6.1; rv:10.0) Gecko/20100101 Firefox/10.0"
   fi

   if [ "$SDWDATE_USE_SCLOCKADJ_WHEN_STARTUP" = "" ]; then
      SDWDATE_USE_SCLOCKADJ_WHEN_STARTUP="0"
   fi

   if [ "$SDWDATE_USE_SCLOCKADJ_WHEN_DAEMON" = "" ]; then
      SDWDATE_USE_SCLOCKADJ_WHEN_DAEMON="1"
   fi

   if [ "$SDWDATE_SCLOCKADJ_VERBOSE" = "" ]; then
      SDWDATE_SCLOCKADJ_VERBOSE="--no-verbose"
   fi

   if [ "$SDWDATE_SCLOCKADJ_CHANGE_DATE" = "" ]; then
      SDWDATE_SCLOCKADJ_CHANGE_DATE="--no-debug"
   fi

   if [ "$SDWDATE_SCLOCKADJ_FIRST_WAIT" = "" ]; then
      SDWDATE_SCLOCKADJ_FIRST_WAIT="--no-first-wait"
   fi

   if [ "$SDWDATE_SCLOCKADJ_MOVE_MIN" = "" ]; then
      SDWDATE_SCLOCKADJ_MOVE_MIN="500000"
   fi

   if [ "$SDWDATE_SCLOCKADJ_MOVE_MAX" = "" ]; then
      SDWDATE_SCLOCKADJ_MOVE_MAX="500000"
   fi

   if [ "$SDWDATE_SCLOCKADJ_WAIT_MIN" = "" ]; then
      SDWDATE_SCLOCKADJ_WAIT_MIN="1000000000"
   fi

   if [ "$SDWDATE_SCLOCKADJ_WAIT_MAX" = "" ]; then
      SDWDATE_SCLOCKADJ_WAIT_MAX="1000000000"
   fi

   if [ "$TIME_FETCHING_METHOD" = "" ]; then
      TIME_FETCHING_METHOD="curl"
   fi

   if [ "$TLSDATE_EXTRA_OPTIONS" = "" ]; then
      TLSDATE_EXTRA_OPTIONS=""
   fi

   if [ "${SDWDATE_CURL_DISPATCH_PRE[SDWDATE_POOL_ONE]}" = "" ]; then
      declare -A -g SDWDATE_CURL_DISPATCH_PRE
      SDWDATE_CURL_DISPATCH_PRE[SDWDATE_POOL_ONE]="true"
   fi

   if [ "${SDWDATE_CURL_DISPATCH_POST[SDWDATE_POOL_ONE]}" = "" ]; then
      declare -A -g SDWDATE_CURL_DISPATCH_POST
      SDWDATE_CURL_DISPATCH_POST[SDWDATE_POOL_ONE]="true"
   fi

   if [ "${SDWDATE_CURL_DISPATCH_PRE[SDWDATE_POOL_TWO]}" = "" ]; then
      declare -A -g SDWDATE_CURL_DISPATCH_PRE
      SDWDATE_CURL_DISPATCH_PRE[SDWDATE_POOL_TWO]="true"
   fi

   if [ "${SDWDATE_CURL_DISPATCH_POST[SDWDATE_POOL_TWO]}" = "" ]; then
      declare -A -g SDWDATE_CURL_DISPATCH_POST
      SDWDATE_CURL_DISPATCH_POST[SDWDATE_POOL_TWO]="true"
   fi

   if [ "${SDWDATE_CURL_DISPATCH_PRE[SDWDATE_POOL_THREE]}" = "" ]; then
      declare -A -g SDWDATE_CURL_DISPATCH_PRE
      SDWDATE_CURL_DISPATCH_PRE[SDWDATE_POOL_THREE]="true"
   fi

   if [ "${SDWDATE_CURL_DISPATCH_POST[SDWDATE_POOL_THREE]}" = "" ]; then
      declare -A -g SDWDATE_CURL_DISPATCH_POST
      SDWDATE_CURL_DISPATCH_POST[SDWDATE_POOL_THREE]="true"
   fi

   if [ "$SDWDATE_POOL_ONE" = "" ]; then
      declare -g SDWDATE_POOL_ONE

      SDWDATE_POOL_ONE=(
         boum.org
         chavez.indymedia.org
         db.debian.org
         debian.org
         epic.org
         mail.riseup.net
         sarava.org
         squat.net
         tachanka.org
         www.1984.is
         www.eff.org
         www.immerda.ch
         www.privacyinternational.org
         www.torproject.org
         freedom.press
      )
   fi

   if [ "$SDWDATE_POOL_TWO" = "" ]; then
      declare -g SDWDATE_POOL_TWO

      SDWDATE_POOL_TWO=(
         grc.com
         www.tarsnap.com
         wikileaks.org
         pressfreedomfoundation.org
         securedrop.theguardian.com
         safesource.forbes.com
         en.wikipedia.org
         cve.mitre.org
         duckduckgo.com
         lkml.org
         www.gnu.org
         fsf.org
         fsfe.org
         defectivebydesign.org
         www.kernel.org
         opentechfund.org
         firstlook.org
      )
   fi

   if [ "$SDWDATE_POOL_THREE" = "" ]; then
      declare -g SDWDATE_POOL_THREE

      SDWDATE_POOL_THREE=(
         www.startpage.com
         www.apache.org
         www.centos.org
         www.piratenpartei.de
         www.torservers.net
         www.accessnow.org
         rsf.org
         www.wauland.de
         www.ccc.de
         netzpolitik.org
         privacyfoundation.ch
         www.noisebridge.net
         en.bitcoin.it
         www.calyxinstitute.org
         gnupg.org
         gpgtools.org
         schneier.com
      )
   fi
}

sdwdate_read_config_folder() {
   trap "sdwdate_error_handler" ERR

   declare -A -g SDWDATE_CURL_DISPATCH_PRE
   declare -A -g SDWDATE_CURL_DISPATCH_POST

   if [ "$NOCONFIG" = "1" ]; then
      return 0
   fi
   for i in /etc/sdwdate.d/*; do
      if [ -f "$i" ]; then
         ## If the last character is a ~, ignore that file, because it was created
         ## by some editor, which creates backup files.
         if [ "${i: -1}" = "~" ]; then
            continue
         fi
         ## Skipping files such as .dpkg-old and .dpkg-dist.
         if ( echo "$i" | grep -q ".dpkg-" ); then
            true "skip $i"
            continue
         fi
         local bash_n_exit_code bash_n_output
         bash_n_exit_code="0"
         bash_n_output="$(bash -n "$i" 2>&1)" || { bash_n_exit_code="$?" ; true; };
         if [ ! "$bash_n_exit_code" = "0" ]; then
            sdwdate_error_handler "Invalid config file: $i
bash_n_exit_code: $bash_n_exit_code
bash_n_output:
$bash_n_output"
         fi
         source "$i"
      fi
   done
}

sdwdate_parse_cmd_options() {
   trap "sdwdate_error_handler" ERR

   ## Thanks to:
   ## http://mywiki.wooledge.org/BashFAQ/035

   while :
   do
       case $1 in
           -h | --help | -\?)
               sdwdate_usage
               exit 0
               ;;
           -d | --debug)
               DEBUG=1
               CURL_VERBOSE=""
               TLSDATE_VERBOSE="--verbose"
               shift
               ;;
           -u | --user)
               USER=$2
               RUN_AS="sudo -u $USER"
               shift 2
               ;;
           -x | --dont_set_date)
               DONT_SET_DATE=1
               shift
               ;;
           --no-move-forward)
               NO_MOVE_FORWARD=1
               shift
               ;;
           --no-move-backwards)
               NO_MOVE_BACKWARDS=1
               shift
               ;;
           --systohc)
               SYSTOHC=1
               SDWDATE_SCLOCKADJ_SYSTOHC="--systohc"
               shift
               ;;
           -a | --user_agent)
               HTTP_USER_AGENT=$2
               shift 2
               ;;
           -l | --log_file)
               LOG_FILE=$2
               shift 2
               ;;
           -D | --done_file)
               DONE_FILE=$2
               shift 2
               ;;
           -T | --success_file)
               SUCCESS_FILE=$2
               shift 2
               ;;
           -P | --pool_one)
               SDWDATE_POOL_ONE=$2
               shift 2
               ;;
           -N | --pool_two)
               SDWDATE_POOL_TWO=$2
               shift 2
               ;;
           -F | --pool_three)
               SDWDATE_POOL_THREE=$2
               shift 2
               ;;
           -A | --allowed_per_pool_failure_ratio)
               ALLOWED_PER_POOL_FAILURE_RATIO=$2
               shift 2
               ;;
           -p | --proxy)
               PROXY=$2
               shift 2
               ;;
           -i | --interval)
               INTERVAL=$2
               shift 2
               ;;
           --mininterval)
               MIN_INTERVAL=$2
               shift 2
               ;;
           -n | --noconfig)
               NOCONFIG="1"
               shift 1
               ;;
           --parsecmd_only_on_startup)
               PARSE_CMD_ONLY_ON_STARTUP="1"
               shift 1
               ;;
           -r | --randomize)
               RANDOMIZE="1"
               shift 1
               ;;
           --timewarp-on-startup)
               SDWDATE_USE_SCLOCKADJ_WHEN_STARTUP="0"
               shift 1
               ;;
           --timewarp-on-daemon)
               SDWDATE_USE_SCLOCKADJ_WHEN_DAEMON="0"
               shift 1
               ;;
           --sclockadj-on-startup)
               SDWDATE_USE_SCLOCKADJ_WHEN_STARTUP="1"
               shift 1
               ;;
           --sclockadj-on-daemon)
               SDWDATE_USE_SCLOCKADJ_WHEN_DAEMON="1"
               shift 1
               ;;
           --sclockadj-verbose)
               SDWDATE_SCLOCKADJ_VERBOSE="--verbose"
               shift 1
               ;;
           --sclockadj-no-change-date)
               SDWDATE_SCLOCKADJ_CHANGE_DATE="--debug"
               shift 1
               ;;
           --sclockadj-first-wait)
               SDWDATE_SCLOCKADJ_FIRST_WAIT="--first-wait"
               shift 1
               ;;
           --sclockadj-move-min)
               SDWDATE_SCLOCKADJ_MOVE_MIN=$2
               shift 2
               ;;
           --sclockadj-move-max)
               SDWDATE_SCLOCKADJ_MOVE_MAX=$2
               shift 2
               ;;
           --sclockadj-wait-min)
               SDWDATE_SCLOCKADJ_WAIT_MIN=$2
               shift 2
               ;;
           --sclockadj-wait-max)
               SDWDATE_SCLOCKADJ_WAIT_MAX=$2
               shift 2
               ;;
           -y | --dispatchprerequisite)
               DISPATCH_PREREQUISITE=$2
               shift 2
               ;;
           -m | --dispatchposterror)
               DISPATCH_POST_ERROR=$2
               shift 2
               ;;
           --nodonefileonerror)
               SDW_TOUCH_DONE_FILE_ON_ERROR="0"
               shift 2
               ;;
           --noexitonerror)
               SDW_EXIT_ON_ERROR="0"
               shift 2
               ;;
           -w | --dispatchpre)
               DISPATCH_PRE=$2
               shift 2
               ;;
           -x | --dispatchpostsuccess)
               DISPATCH_POST_SUCCESS=$2
               shift 2
               ;;
           -z | --dispatchpostfailure)
               DISPATCH_POST_FAILURE=$2
               shift 2
               ;;
           --dispatch_pre_one)
               SDWDATE_CURL_DISPATCH_PRE[SDWDATE_POOL_ONE]=$2
               shift 2
               ;;
           --dispatch_post_one)
               SDWDATE_CURL_DISPATCH_POST[SDWDATE_POOL_ONE]=$2
               shift 2
               ;;
           --dispatch_pre_two)
               SDWDATE_CURL_DISPATCH_PRE[SDWDATE_POOL_TWO]=$2
               shift 2
               ;;
           --dispatch_post_two)
               SDWDATE_CURL_DISPATCH_POST[SDWDATE_POOL_TWO]=$2
               shift 2
               ;;
           --dispatch_pre_three)
               SDWDATE_CURL_DISPATCH_PRE[SDWDATE_POOL_THREE]=$2
               shift 2
               ;;
           --dispatch_post_three)
               SDWDATE_CURL_DISPATCH_POST[SDWDATE_POOL_THREE]=$2
               shift 2
               ;;
           -q | --quiet)
               QUIET=1
               shift
               ;;
           --time-fetching-method)
               TIME_FETCHING_METHOD=$2
               shift 2
               ;;
           --tlsdate-extra-options)
               TLSDATE_EXTRA_OPTIONS=$2
               shift 2
               ;;
           --)
               shift
               break
               ;;
           -*)
               sdwdate_log "$SCRIPTNAME unknown option: $1" >&2
               exit 1
               ;;
           *)
               break
               ;;
       esac
   done

   ## If there are input files (for example) that follow the options, they
   ## will remain in the "$@" positional parameters.
}

sdwdate_preparation() {
   trap "sdwdate_error_handler" ERR

   mkdir --parents "$(dirname "$LOG_FILE")"
   mkdir --parents "$(dirname "$DONE_FILE")"
   mkdir --parents "$(dirname "$SUCCESS_FILE")"

   rm --force "$DONE_FILE"
   rm --force "$SUCCESS_FILE"

   declare -A -g sdwdate_curl_exit_code
   declare -A -g SDWDATE_CURL_PID
   declare -A -g SDWDATE_DOWNLOAD_TOOK_TIME

   if [ "$HTTP_USER_AGENT" = "" ]; then
      CURL_USER_AGENT=""
   else
      CURL_USER_AGENT="--user-agent $HTTP_USER_AGENT"
   fi

   local ret
   ret="0"
   command -v curl.anondist-orig >/dev/null || { ret="$?" ; true; };

   if [ "$ret" = "0" ]; then
      ## using the non-uwt-wrapped version, if the uwt wrapper is installed,
      ## which is the case on a default Whonix installation
      sdwdate_log "$FUNCNAME: Setting CURL to curl.anondist-orig."
      export CURL=curl.anondist-orig
   else
      local ret
      ret="0"
      command -v curl >/dev/null || { ret="$?" ; true; };
      if [ "$ret" = "0" ]; then
         ## falling back to real curl, if the uwt wrapper has been uninstalled
         sdwdate_log "$FUNCNAME: Setting CURL to curl."
         export CURL=curl
      else
         sdwdate_log "$FUNCNAME: Can not find curl. Please report this bug!"
         exit 1
      fi
   fi

   if [ "$who_ami" = "" ]; then
      ## Required for eventual plugins.
      who_ami="$(whoami)"
   fi
   sdwdate_log "$FUNCNAME: who_ami is set to $who_ami."

   sdwdate_log "$FUNCNAME: TIME_FETCHING_METHOD is set to $TIME_FETCHING_METHOD."
}

sdwdate_echo() {
   trap "sdwdate_error_handler" ERR

   if [ "$QUIET" = "1" ]; then
      true
   else
      echo "$@"
   fi
}

sdwdate_write_log() {
   trap "sdwdate_error_handler" ERR

   ## Default, if the error happens before defaults are set and before config
   ## files are read.
   if [ "$LOG_FILE" = "" ]; then
      LOG_FILE="/var/log/sdwdate.log"
   fi

   if [ "$LOG_FILE" = "" ]; then
      true
   else
      echo "$@" >> "$LOG_FILE"
   fi
}

sdwdate_log() {
   trap "sdwdate_error_handler" ERR

   if [ "$ID" = "" ] ; then
      ID="No_ID"
   fi

   local msg msg_string_length max_log_string_length
   msg="$ID: $@"
   msg_string_length="${#msg}"
   max_log_string_length="500"

   if [ "$msg_string_length" -gt "$max_log_string_length" ]; then
      ## Shorten excess length $msg to $max_log_string_length chars.
      msg="${msg:0:$max_log_string_length}"
      msg="${msg} ||| Shortened log msg string length!"
   fi

   swddate_last_but_one_msg="$swddate_last_msg"
   swddate_last_msg="$msg"

   sdwdate_echo "$msg"
   sdwdate_write_log "$msg"
}

sdwdate_no_duplicate_log() {
   trap "sdwdate_error_handler" ERR

   if [ ! -f "$LOG_FILE" ]; then
      sdwdate_log "$@"
      return 0
   fi

   if [ "$swddate_last_msg" = "$ID: $@" ]; then
      return 0
   fi
   if [ "$swddate_last_but_one_msg" = "$ID: $@" ]; then
      return 0
   fi

   sdwdate_log "$@"
}

sdwdate_error_handler() {
   local exit_code="$?"
   local error_cause error_text
   error_text="$1"
   if [ "$error_text" = "" ]; then
      error_cause="$FUNCNAME signal ERR detected with BASH_COMMAND:
$BASH_COMMAND"
   else
      error_cause="$FUNCNAME called with error_text:
$error_text"
   fi

   ## Default, if the error happens before defaults are set and before config
   ## files are read.
   if [ "$SDW_EXIT_ON_ERROR" = "" ]; then
      SDW_EXIT_ON_ERROR="1"
   fi

   local error_message
   error_message="
############################################
## Error detected! Please report this bug! #
##
## BASH_SOURCE: $BASH_SOURCE
## SDW_EXIT_ON_ERROR: $SDW_EXIT_ON_ERROR
## SDW_MODE: $SDW_MODE
## SDWDATE_SUBSHELL_SCLOCKADJ_EXIT_CODE: $SDWDATE_SUBSHELL_SCLOCKADJ_EXIT_CODE
##
## exit_code: $exit_code
## error_cause: $error_cause
############################################\
"

   sdwdate_log "error_message: $error_message"

   true "DISPATCH_POST_ERROR: $DISPATCH_POST_ERROR"

   local ret
   if [ "$SDW_TOUCH_DONE_FILE_ON_ERROR" = "1" ]; then
      touch "$DONE_FILE"
      ret="$?"
      if [ ! "$ret" = "0" ]; then
         sdwdate_log "ERROR $BASH_SOURCE: Could not touch DONE_FILE: $DONE_FILE."
      fi
   fi

   if [ "$DISPATCH_POST_ERROR" = "" ]; then
      true
   else
      sdwdate_no_duplicate_log "dispatching post_error (SDW_MODE: $SDW_MODE): $DISPATCH_POST_ERROR"
      eval $DISPATCH_POST_ERROR
   fi

   if [ "$SDW_EXIT_ON_ERROR" = "1" ]; then
      sdwdate_log "$SCRIPTNAME (not timesync!): Error detected. Cleaning up..."
      SIGNAL_TYPE="ERR"
      if [ "$(command -v "sdwdate_ex_funct")" ]; then
         sdwdate_ex_funct || true
      fi
      sdwdate_log "$SCRIPTNAME (not timesync!): Error detected. Exiting."
      exit 1
   else
      sdwdate_log "$SCRIPTNAME (not timesync!): Error detected. Continuing."
   fi
}

trap "sdwdate_error_handler" ERR

sdwdate_sanity_tests() {
   trap "sdwdate_error_handler" ERR

   command -v bash >/dev/null
   command -v bc >/dev/null
   command -v uuidgen >/dev/null
   command -v basename >/dev/null
   command -v mktemp >/dev/null
   command -v touch >/dev/null
   command -v dirname >/dev/null
   command -v awk >/dev/null
   command -v date >/dev/null
   ## Using GNU's printf instead of bash's printf.
   command -v /usr/bin/printf >/dev/null
   command -v od >/dev/null
   command -v grep >/dev/null
   command -v sudo >/dev/null
   command -v shuf >/dev/null
   command -v /usr/lib/sclockadj >/dev/null
   command -v /sbin/hwclock >/dev/null
   ## TODO: when jessie becomes stable
   #command -v tlsdate >/dev/null

   test -e "/dev/random"
   bash -n "$BASH_SOURCE"
}

sdwdate_ex_funct() {
   trap "sdwdate_error_handler" ERR

   sdwdate_log "$SCRIPTNAME (not timesync!): signal $SIGNAL_TYPE received. Cleaning up..."

   if [ ! "$sleep_pid" = "" ]; then
      kill -9 "$sleep_pid" || true
   fi

   ## Check if function sdwdate_terminate_sclockadj is already available and
   ## use it if available.
   command_v_exit_code="0"
   command -v sdwdate_terminate_sclockadj >/dev/null 2>&1 || { command_v_exit_code="$?" ; true; };
   if [ "$command_v_exit_code" = "0" ]; then
      sdwdate_terminate_sclockadj
   fi

   if [ ! "${SDWDATE_CURL_PID[$SDWDATE_CURRENT_POOL]}" = "" ]; then
      kill -9 "${SDWDATE_CURL_PID[$SDWDATE_CURRENT_POOL]}" || true
   fi

   if [ -d "$TEMP_DIR" ]; then
      rm -r "$TEMP_DIR"
   fi

   if [ ! "$DONE_FILE" = "" ]; then
      touch "$DONE_FILE"
   fi
   sdwdate_log "$SCRIPTNAME (not timesync!): signal $SIGNAL_TYPE received. Exiting."
}

sdwdate_signal_sigint() {
   trap "sdwdate_error_handler" ERR

   SIGNAL_TYPE="SIGINT"
   sdwdate_ex_funct
   exit 130
}

trap "sdwdate_signal_sigint" SIGINT ## ctrl + c

sdwdate_signal_sigterm() {
   trap "sdwdate_error_handler" ERR

   SIGNAL_TYPE="SIGTERM"
   sdwdate_ex_funct
   exit 143
}

trap "sdwdate_signal_sigterm" SIGTERM

sdwdate_enable_debugging() {
   ## usage: kill -sigusr1 pid

   if [ "$SDWDATE_DEBUG_TRACE_SET" ]; then
      return 0
   fi

   set -x

   exec >  >(tee -a "$LOG_FILE")
   exec 2> >(tee -a "$LOG_FILE" >&2)

   set -o functrace
   shopt -s extdebug

   #trap 'true "BASH_COMMAND: $BASH_COMMAND | FUNCNAME: ${FUNCNAME[1]} | BASH_LINENO: ${BASH_LINENO[0]} | BASH_SOURCE: ${BASH_SOURCE[1]}"' DEBUG
   trap 'true "${FUNCNAME[1]}: $BASH_COMMAND"' DEBUG

   SDWDATE_DEBUG_TRACE_SET="1"
}

sdwdate_signal_sigusr1() {
   sdwdate_enable_debugging
}

trap "sdwdate_signal_sigusr1" SIGUSR1

tlsdate_show_log() {
   trap "sdwdate_error_handler" ERR
   local tlsdate_stdout tlsdate_stderr
   if [ -r "$TEMP_DIR/$SDWDATE_CURRENT_POOL" ]; then
      tlsdate_stdout="$(timeout --kill-after 5 5 cat "$TEMP_DIR/$SDWDATE_CURRENT_POOL")" || tlsdate_stdout="timeout/cat exit code: $?"
   fi
   if [ -r "$TEMP_DIR/$SDWDATE_CURRENT_POOL.stderr" ]; then
      tlsdate_stderr="$(timeout --kill-after 5 5 cat "$TEMP_DIR/$SDWDATE_CURRENT_POOL.stderr")" || tlsdate_stderr="timeout/cat exit code: $?"
   fi
   sdwdate_log "tlsdate exit code: ${sdwdate_curl_exit_code[$SDWDATE_CURRENT_POOL]} | tlsdate took ${SDWDATE_DOWNLOAD_TOOK_TIME[$SDWDATE_CURRENT_POOL]}s"
   sdwdate_log "tlsdate stdout: $tlsdate_stdout"
   sdwdate_log "tlsdate stderr: $tlsdate_stderr"
}

sdwdate_get_time_from_remote() {
   trap "sdwdate_error_handler" ERR

   LINK="https://$1"
   LINK_WITHOUT_HTTPS="$1"

   if [ "$PROXY" = "" ]; then
      CURL_PROXY=""
      TLSDATE_PROXY=""
   else
      CURL_PROXY="--socks5-hostname $PROXY"
      TLSDATE_PROXY="--proxy socks5://$PROXY"
   fi

   local current_time
   current_time="$(date)"
   sdwdate_log "getUrlDateDiff: $LINK | $current_time"

   sdwdate_curl_exit_code[$SDWDATE_CURRENT_POOL]="0"

   local TIME_START
   TIME_START="$(date +%s)"

   sdwdate_no_duplicate_log "dispatching SDWDATE_CURL_DISPATCH_PRE[$SDWDATE_CURRENT_POOL] (SDW_MODE: $SDW_MODE) (CURL: $CURL): ${SDWDATE_CURL_DISPATCH_PRE[$SDWDATE_CURRENT_POOL]}"

   if [ "${SDWDATE_CURL_DISPATCH_PRE[$SDWDATE_CURRENT_POOL]}" = "" ]; then
      true
   else
      eval ${SDWDATE_CURL_DISPATCH_PRE[$SDWDATE_CURRENT_POOL]}
   fi

   ## Sanity test.
   touch "$TEMP_DIR/$SDWDATE_CURRENT_POOL"
   rm "$TEMP_DIR/$SDWDATE_CURRENT_POOL"
   touch "$TEMP_DIR/$SDWDATE_CURRENT_POOL.stderr"
   rm "$TEMP_DIR/$SDWDATE_CURRENT_POOL.stderr"

   if [ "$TIME_FETCHING_METHOD" = "curl" ]; then
      ## --fail not required, because also 404 would include head, which is all we need
      $CURL \
         --tlsv1 \
         --proto =https \
         --max-time 180 \
         --head \
         $CURL_PROXY \
         $CURL_VERBOSE \
         $CURL_USER_AGENT \
         --output "$TEMP_DIR/$SDWDATE_CURRENT_POOL" \
         "$LINK" \
         &
   elif [ "$TIME_FETCHING_METHOD" = "tlsdate" ]; then
      ## - tlsdate does not always timeout:
      ##   https://github.com/ioerror/tlsdate/issues/149
      ## - tlsdate defaults to tlsv1 as per tlsdate's man page.
      ## - Long option --host did not work for some reason. Short option -H
      ##   however worked fine.
      ## - tlsdate does not work with -H https://www.torproject.org, but with
      ##   -H www.torproject.org.
      ## - Using --showtime=human, because --showtime=raw does not work.

      sdwdate_log "Running: timeout --kill-after 5 180 \
         tlsdate \
         $TLSDATE_PROXY \
         $TLSDATE_VERBOSE \
         $TLSDATE_EXTRA_OPTIONS \
         --dont-set-clock \
         --showtime=human \
         -H \"$LINK_WITHOUT_HTTPS\" \
         > \"$TEMP_DIR/$SDWDATE_CURRENT_POOL\" \
         2> \"$TEMP_DIR/$SDWDATE_CURRENT_POOL.stderr\" \
         &"

      timeout --kill-after 5 180 \
         tlsdate \
            $TLSDATE_PROXY \
            $TLSDATE_VERBOSE \
            $TLSDATE_EXTRA_OPTIONS \
            --dont-set-clock \
            --showtime=human \
            -H "$LINK_WITHOUT_HTTPS" \
            > "$TEMP_DIR/$SDWDATE_CURRENT_POOL" \
            2> "$TEMP_DIR/$SDWDATE_CURRENT_POOL.stderr" \
            &

      ## `timeout` returns:
      ## - 124 if sigterm was sufficient
      ## - 137 if needed to use kill.
   else
      msg="Unknown TIME_FETCHING_METHOD: $TIME_FETCHING_METHOD."
      error "$msg"
   fi

   SDWDATE_CURL_PID[$SDWDATE_CURRENT_POOL]="$!"

   sdwdate_curl_exit_code[$SDWDATE_CURRENT_POOL]="0"
   wait "${SDWDATE_CURL_PID[$SDWDATE_CURRENT_POOL]}" || { sdwdate_curl_exit_code[$SDWDATE_CURRENT_POOL]="$?" ; true; };
   unset SDWDATE_CURL_PID[$SDWDATE_CURRENT_POOL]

   true "INFO: sdwdate_curl_exit_code[$SDWDATE_CURRENT_POOL]: ${sdwdate_curl_exit_code[$SDWDATE_CURRENT_POOL]}"

   local TIME_END
   TIME_END="$(date +%s)"

   true "SDWDATE_DOWNLOAD_TOOK_TIME[$SDWDATE_CURRENT_POOL]="\$\(\( $TIME_END - $TIME_START \)\)""
   SDWDATE_DOWNLOAD_TOOK_TIME[$SDWDATE_CURRENT_POOL]="$(( $TIME_END - $TIME_START ))"

   if [ "${sdwdate_curl_exit_code[$SDWDATE_CURRENT_POOL]}" = "124" ]; then
      sdwdate_log "Timeout triggered (sigterm was sufficient). (exit code: ${sdwdate_curl_exit_code[$SDWDATE_CURRENT_POOL]})"
   elif [ "${sdwdate_curl_exit_code[$SDWDATE_CURRENT_POOL]}" = "137" ]; then
      sdwdate_log "Timeout triggered (kill was required). (exit code: ${sdwdate_curl_exit_code[$SDWDATE_CURRENT_POOL]})"
   fi

   if [ ! "${sdwdate_curl_exit_code[$SDWDATE_CURRENT_POOL]}" = "0" ]; then
      if [ "$TIME_FETCHING_METHOD" = "curl" ]; then
         local command_v_exit_code="0"
         command -v /usr/lib/curl-scripts/curl_exit_codes > /dev/null || { command_v_exit_code="$?" ; true; };
         if [ "$command_v_exit_code" = "0" ]; then
            ## If /usr/lib/curl-scripts/curl_exit_codes available, use it.
            local curl_status_message
            curl_status_message="$(/usr/lib/curl-scripts/curl_exit_codes "${sdwdate_curl_exit_code[$SDWDATE_CURRENT_POOL]}")" || true
            sdwdate_log "No file could be downloaded from $LINK. (took ${SDWDATE_DOWNLOAD_TOOK_TIME[$SDWDATE_CURRENT_POOL]}s) (curl_exit_code: ${sdwdate_curl_exit_code[$SDWDATE_CURRENT_POOL]} | curl_status_message: $curl_status_message)"
         else
            ## Fallback if /usr/lib/curl-scripts/curl_exit_codes is not available.
            sdwdate_log "No file could be downloaded from $LINK. (took ${SDWDATE_DOWNLOAD_TOOK_TIME[$SDWDATE_CURRENT_POOL]}s) (curl_exit_code: ${sdwdate_curl_exit_code[$SDWDATE_CURRENT_POOL]})"
         fi
      elif [ "$TIME_FETCHING_METHOD" = "tlsdate" ]; then
         sdwdate_log "No time could be obtained from $LINK. (took ${SDWDATE_DOWNLOAD_TOOK_TIME[$SDWDATE_CURRENT_POOL]}s) (tlsdate exit code: ${sdwdate_curl_exit_code[$SDWDATE_CURRENT_POOL]})"
         tlsdate_show_log
      else
         msg="Unknown TIME_FETCHING_METHOD: $TIME_FETCHING_METHOD."
         error "$msg"
      fi
      return 0
   fi

   if [ "$TIME_FETCHING_METHOD" = "tlsdate" ]; then
      tlsdate_show_log
   fi

   test -f "$TEMP_DIR/$SDWDATE_CURRENT_POOL"

   sdwdate_no_duplicate_log "dispatching SDWDATE_CURL_DISPATCH_POST[$SDWDATE_CURRENT_POOL]: ${SDWDATE_CURL_DISPATCH_POST[$SDWDATE_CURRENT_POOL]}"

   if [ "${SDWDATE_CURL_DISPATCH_POST[$SDWDATE_CURRENT_POOL]}" = "" ]; then
      true
   else
      eval ${SDWDATE_CURL_DISPATCH_POST[$SDWDATE_CURRENT_POOL]}
   fi

   return 0
}

sdwdate_parse_date() {
   trap "sdwdate_error_handler" ERR

   SDWDATE_PARSE_SUCCESS="1"

   test -f "$TEMP_DIR/$SDWDATE_CURRENT_POOL"

   if [ "$TIME_FETCHING_METHOD" = "tlsdate" ]; then
      ## Parsing not required. tlsdate already did that.
      WEB_DATE_FROM_TOOL="$(timeout --kill-after 5 5 cat "$TEMP_DIR/$SDWDATE_CURRENT_POOL")" || WEB_DATE_FROM_TOOL="timeout/cat exit code: $?"
      SDWDATE_PARSE_SUCCESS="0"
      return 0
   fi

   local i
   i="0"
   local LINE
   while read -r LINE; do
      true "i="\$\(\( $i + 1 \)\)""
      i="$(( $i + 1 ))"
      true "INFO: LINE: $LINE"
      local LINE_LENGTH
      LINE_LENGTH="${#LINE}"
      true "Reply from $LINK. i: $i LINE_LENGTH: $LINE_LENGTH"

      if [ "$i" -gt "20" ]; then
         sdwdate_log "Bogus reply from $LINK did not include the \"Date\" field."
         break
      fi

      local FIRST_WORD
      FIRST_WORD="${LINE%%:*}"
      ## twitter used Date in lower case
      if [ "${FIRST_WORD,,}" = "date" ]; then
         ## TODO: do not hard code 36
         if [ "$LINE_LENGTH" -gt "36" ]; then
            sdwdate_log "Bogus reply from $LINK for the \"Date\" field. Excessive line length: $LINE_LENGTH"
            break
         fi
         ## TODO: do not hard code 36
         if [ ! "$LINE_LENGTH" = "36" ]; then
            sdwdate_log "Bogus reply from $LINK for the \"Date\" field. Line length $LINE_LENGTH does not equal expected 36."
            break
         fi
         true "Reply from $LINK for the \"Date\" field. Line length: $LINE_LENGTH"

         WEB_DATE_FROM_TOOL="${LINE#*:}"
         SDWDATE_PARSE_SUCCESS="0"
         break
      fi
   done < "$TEMP_DIR/$SDWDATE_CURRENT_POOL"
}

sdwdate_convert_to_unixtime() {
   trap "sdwdate_error_handler" ERR

   SDWDATE_CONVERT_SUCCESS="0"

   WEB_DATE_UNIXTIME="$(date --date="$WEB_DATE_FROM_TOOL" +"%s")" || { SDWDATE_CONVERT_SUCCESS="$?" ; true; };

   if [ ! "$SDWDATE_CONVERT_SUCCESS" = "0" ]; then
      sdwdate_log "Bogus reply from $LINK. Could not convert to unixtime. \
\`date\` failed with exit code: $SDWDATE_CONVERT_SUCCESS. WEB_DATE_FROM_TOOL: $WEB_DATE_FROM_TOOL | date stdout: $WEB_DATE_UNIXTIME"
      return 0
   fi

   local WEB_DATE_UNIXTIME_STRING_LENGTH
   WEB_DATE_UNIXTIME_STRING_LENGTH="${#WEB_DATE_UNIXTIME}"

   ## TODO: do not hard code 12
   if [ "$WEB_DATE_UNIXTIME_STRING_LENGTH" -gt "12" ]; then
      SDWDATE_CONVERT_SUCCESS="false"
      sdwdate_log "Bogus reply from $LINK. Could not convert to unixtime. String length of WEB_DATE_UNIXTIME is bigger than 12, it is: $WEB_DATE_UNIXTIME_STRING_LENGTH"
      return 0
   else
      true "Reply from $LINK WEB_DATE_UNIXTIME string length is exactly 10."
   fi

   if [[ "$WEB_DATE_UNIXTIME" != *[!0-9]* ]]; then
      true "Reply from $LINK WEB_DATE_UNIXTIME is strictly numeric. WEB_DATE_UNIXTIME: $WEB_DATE_UNIXTIME"
   else
      SDWDATE_CONVERT_SUCCESS="false"
      sdwdate_log "Bogus reply from $LINK. Could not convert to unixtime. Result is not strictly numeric. WEB_DATE_UNIXTIME: $WEB_DATE_UNIXTIME"
      return 0
   fi
}

sdwdate_loop() {
   trap "sdwdate_error_handler" ERR

   eval "array=(\${$SDWDATE_CURRENT_POOL[@]})"

   unset remember
   declare -A -g remember

   while true; do
      local array_length
      array_length="${#array[@]}"
      local array_length_remember
      array_length_remember="${#remember[@]}"

      if [ "$array_length" = "0" ]; then
         sdwdate_log "ERROR: $SDWDATE_CURRENT_POOL not configured!"

         ## Check, if we are running in daemon mode.
         if [ "$INTERVAL" = "" ] || [ "$INTERVAL" = "0" ]; then
            ## No daemon mode.
            exit 1
         else
            ## Daemon mode.
            return 1
         fi
      fi

      if [ "$array_length_remember" -ge "$array_length" ]; then
         sdwdate_log "ERROR: No member of the $SDWDATE_CURRENT_POOL could not be reached. (debugging information: array_length_remember: $array_length_remember | array_length: $array_length)"

         ## Check, if we are running in daemon mode.
         if [ "$INTERVAL" = "" ] || [ "$INTERVAL" = "0" ]; then
            ## No daemon mode.
            exit 1
         else
            ## Daemon mode.
            return 1
         fi
      fi

      local temp
      temp="$(bc -l <<< "$array_length*$ALLOWED_PER_POOL_FAILURE_RATIO")"
      ## adjust upward / downward
      local allowed_member_failures
      allowed_member_failures="$(/usr/bin/printf "%.f" "$temp")"
      sdwdate_log "allowed_member_failures: $allowed_member_failures (debugging information: temp: $temp | $SDWDATE_CURRENT_POOL array_length: $array_length | array_length_remember: $array_length_remember)"
      if [ "$allowed_member_failures" = "0" ]; then
         allowed_member_failures="1"
         sdwdate_log "allowed_member_failures (can not be 0): $allowed_member_failures"
      fi

      if [ "$array_length_remember" -ge "$allowed_member_failures" ]; then
         sdwdate_log "ERROR: $allowed_member_failures members of the $SDWDATE_CURRENT_POOL could not be reached. (debugging information: array_length_remember: $array_length_remember | allowed_member_failures: $allowed_member_failures)"

         ## Check, if we are running in daemon mode.
         if [ "$INTERVAL" = "" ] || [ "$INTERVAL" = "0" ]; then
            ## No daemon mode.
            exit 1
         else
            ## Daemon mode.
            return 1
         fi
      fi

      test -e "/dev/random"
      local random_integer
      random_integer="$(( ($(od -An -N2 -i "/dev/random") )%($array_length) ))"

      if [ "${remember[$random_integer]}" = "1" ]; then
         continue
      fi

      sdwdate_get_time_from_remote "${array[$random_integer]}"

      if [ ! "${sdwdate_curl_exit_code[$SDWDATE_CURRENT_POOL]}" = "0" ]; then
         remember[$random_integer]=1
         continue
      fi

      ## sets: SDWDATE_PARSE_SUCCESS
      sdwdate_parse_date

      if [ ! "$SDWDATE_PARSE_SUCCESS" = "0" ]; then
         remember[$random_integer]=1
         continue
      fi

      ## sets: WEB_DATE_UNIXTIME
      sdwdate_convert_to_unixtime

      if [ ! "$SDWDATE_CONVERT_SUCCESS" = "0" ]; then
         remember[$random_integer]=1
         continue
      fi

      local OLD_UNIXTIME
      OLD_UNIXTIME="$(date +%s)"

      true "SDWDATE_TIME_DIFF[$SDWDATE_CURRENT_POOL]="\$\(\( $WEB_DATE_UNIXTIME - $OLD_UNIXTIME \)\)""
      SDWDATE_TIME_DIFF[$SDWDATE_CURRENT_POOL]="$(( $WEB_DATE_UNIXTIME - $OLD_UNIXTIME ))"

      ## TODO
      sdwdate_log "$LINK (took ${SDWDATE_DOWNLOAD_TOOK_TIME[$SDWDATE_CURRENT_POOL]}s) => diff = ${SDWDATE_TIME_DIFF[$SDWDATE_CURRENT_POOL]} second(s)"

      break
   done

   unset remember

   return 0
}

sdwdate_pick() {
   trap "sdwdate_error_handler" ERR

   declare -A -g SDWDATE_RESULT
   declare -A -g SDWDATE_TIME_DIFF

   for SDWDATE_CURRENT_POOL in SDWDATE_POOL_ONE SDWDATE_POOL_TWO SDWDATE_POOL_THREE; do
      ## Temporarily disabling error handler.
      ## Not using
      ## || { sdwdate_loop_return="?"; true; };
      ## here, because then errors any errors caught in sdwdate_loop would be
      ## ignored here.
      trap "" ERR
      sdwdate_loop "$SDWDATE_CURRENT_POOL"
      sdwdate_loop_return="$?"
      trap "sdwdate_error_handler" ERR

      ## Do not continue, if an error was caught.
      if [ ! "$sdwdate_loop_return" = "0" ]; then
         return 0
      fi

      SDWDATE_RESULT[$SDWDATE_CURRENT_POOL]="$WEB_DATE_UNIXTIME"

      true "INFO: SDWDATE_RESULT[$SDWDATE_CURRENT_POOL] = ${SDWDATE_RESULT[$SDWDATE_CURRENT_POOL]} | $(date --date "@${SDWDATE_RESULT[$SDWDATE_CURRENT_POOL]}")"
   done
}

sdwdate_build_median() {
   trap "sdwdate_error_handler" ERR

   local results results_list min max
   results="${SDWDATE_TIME_DIFF[SDWDATE_POOL_ONE]} ${SDWDATE_TIME_DIFF[SDWDATE_POOL_TWO]} ${SDWDATE_TIME_DIFF[SDWDATE_POOL_THREE]}"
   sdwdate_log "Results summary: \
one: ${SDWDATE_TIME_DIFF[SDWDATE_POOL_ONE]} | \
two: ${SDWDATE_TIME_DIFF[SDWDATE_POOL_TWO]} | \
three: ${SDWDATE_TIME_DIFF[SDWDATE_POOL_THREE]} | \
second(s)"

   ## Thanks to NotANumber
   ## http://unix.stackexchange.com/a/93949
   results_list=(
      $(
         for item in $results; do
            /usr/bin/printf "%d\n" "$item"
         done | sort -n
      )
   )
   min="${results_list[0]}"
   max="${results_list[${#results_list[*]}-1]}"
   SDWDATE_MEDIAN_TIME_SECONDS="${results_list[${#results_list[*]}/2]}"

   true "SDWDATE_MEDIAN_TIME_NANOSECONDS="\$\(\( $SDWDATE_MEDIAN_TIME_SECONDS \* 1000000000 \)\)""
   SDWDATE_MEDIAN_TIME_NANOSECONDS="$(( $SDWDATE_MEDIAN_TIME_SECONDS * 1000000000 ))"

   sdwdate_log "Min: $min | Max: $max | Median diff: $SDWDATE_MEDIAN_TIME_SECONDS second(s) [$SDWDATE_MEDIAN_TIME_NANOSECONDS nanosecond(s)]"
}

sdwdate_generate_nanoseconds() {
   trap "sdwdate_error_handler" ERR

   local ZERO_OR_ONE
   ## Get a random 0 or 1.
   ## Will use this to decide to use plus or minus.
   ##
   ## Thanks to
   ## http://linux.byexamples.com/archives/128/generating-random-numbers/
   test -e "/dev/random"
   ZERO_OR_ONE="$(( 0+($(od -An -N2 -i "/dev/random") )%(0+2) ))"

   if [ "$ZERO_OR_ONE" = "0" ]; then
      PLUS_OR_MINUS="-"
   elif [ "$ZERO_OR_ONE" = "1" ]; then
      PLUS_OR_MINUS="+"
   else
      sdwdate_error_handler "ZERO_OR_ONE is neither 0 nor 1, it's: $ZERO_OR_ONE"
   fi

   ## Create a random number between 0 and 999999999.
   ##
   ## Thanks to
   ## https://stackoverflow.com/questions/22887891/how-can-i-get-a-random-dev-random-number-between-0-and-999999999-in-bash
   test -e "/dev/random"
   NANOSECONDS="$(shuf -i0-999999999 -n1 --random-source="/dev/random")"

   local extra_seconds_without_leading_zero extra_seconds
   extra_seconds_without_leading_zero="$(bc -l <<< "scale=9 ; $NANOSECONDS / 1000000000")"
   extra_seconds="$(printf '%3.9f\n' "$extra_seconds_without_leading_zero")"

   sdwdate_log "Made up random extra ${PLUS_OR_MINUS}${extra_seconds} second[s] [${PLUS_OR_MINUS}${NANOSECONDS} nanosecond(s)]."
}

sdwdate_set_time_using_date() {
   trap "sdwdate_error_handler" ERR

   ## sets: NANOSECONDS
   ## sets: PLUS_OR_MINUS
   sdwdate_generate_nanoseconds

   local SDWDATE_NEW_UNIXTIME_AND_NANOSECONDS_BEFORE_SETTING
   SDWDATE_NEW_UNIXTIME_AND_NANOSECONDS_BEFORE_SETTING="$(date +%s.%N)"
   local SDWDATE_NEW_DATE_BEFORE_SETTING
   SDWDATE_NEW_DATE_BEFORE_SETTING="$(date)"
   sdwdate_log "Time before setting using \`date\`: $SDWDATE_NEW_UNIXTIME_AND_NANOSECONDS_BEFORE_SETTING [$SDWDATE_NEW_DATE_BEFORE_SETTING]"

   local OLD_UNIXTIME
   OLD_UNIXTIME="$(date +%s)"

   local NEW_UNIXTIME
   true "NEW_UNIXTIME="\$\(\( $OLD_UNIXTIME + $SDWDATE_MEDIAN_TIME_SECONDS \)\)""
   NEW_UNIXTIME="$(( $OLD_UNIXTIME + $SDWDATE_MEDIAN_TIME_SECONDS ))"

   local NEW_UNIXTIME_WITH_NANOSECONDS
   NEW_UNIXTIME_WITH_NANOSECONDS="${NEW_UNIXTIME}000000000"

   local SDWDATE_MOVE_TIME_UNIXTIME_WITH_NANOSECONDS
   true "SDWDATE_MOVE_TIME_UNIXTIME_WITH_NANOSECONDS="\$\(\( $NEW_UNIXTIME_WITH_NANOSECONDS $PLUS_OR_MINUS $NANOSECONDS \)\)""
   SDWDATE_MOVE_TIME_UNIXTIME_WITH_NANOSECONDS="$(( $NEW_UNIXTIME_WITH_NANOSECONDS $PLUS_OR_MINUS $NANOSECONDS ))"

   ## {{ SDWDATE_NEW_TIME_FORMATTED_FOR_DATE

   local first_ten last_nine first_ten_string_length last_nine_string_length

   ## unixtime
   first_ten="${SDWDATE_MOVE_TIME_UNIXTIME_WITH_NANOSECONDS:0:10}"

   ## nanoseconds
   last_nine="${SDWDATE_MOVE_TIME_UNIXTIME_WITH_NANOSECONDS:10:19}"

   first_ten_string_length="${#first_ten}"
   last_nine_string_length="${#last_nine}"

   if [ ! "$first_ten_string_length" = "10" ]; then
      sdwdate_error_handler "$FUNCNAME: first_ten: $first_ten | first_ten_string_length: $first_ten_string_length"
   fi

   if [ ! "$last_nine_string_length" = "9" ]; then
      sdwdate_error_handler "$FUNCNAME: last_nine: $last_nine | last_nine_string_length: $last_nine_string_length"
   fi

   local SDWDATE_NEW_TIME_FORMATTED_FOR_DATE
   ## unixtime.nanoseconds
   SDWDATE_NEW_TIME_FORMATTED_FOR_DATE="$first_ten.$last_nine"

   ## Example SDWDATE_NEW_TIME_FORMATTED_FOR_DATE:
   ## 1405043428.773182656

   ## }} SDWDATE_NEW_TIME_FORMATTED_FOR_DATE

   sdwdate_log "Setting time to $SDWDATE_NEW_TIME_FORMATTED_FOR_DATE..."

   ## Set new time. Syntax: date --set @1396733199.112834496
   ## There is an exception in /etc/sudoers.d/sdwdate.
   sudo /bin/date --set "@"$SDWDATE_NEW_TIME_FORMATTED_FOR_DATE"" > /dev/null

   local SDWDATE_NEW_UNIXTIME_AND_NANOSECONDS_AFTER_SETTING
   SDWDATE_NEW_UNIXTIME_AND_NANOSECONDS_AFTER_SETTING="$(date +%s.%N)"
   local SDWDATE_NEW_DATE_AFTER_SETTING
   SDWDATE_NEW_DATE_AFTER_SETTING="$(date)"
   sdwdate_log "Time after setting using \`date\`: $SDWDATE_NEW_UNIXTIME_AND_NANOSECONDS_AFTER_SETTING [$SDWDATE_NEW_DATE_AFTER_SETTING]"

   if [ "$SYSTOHC" = "1" ]; then
      sudo /sbin/hwclock --systohc
   fi
}

sdwdate_terminate_sclockadj() {
   trap "sdwdate_error_handler" ERR

   if [ "$SDWDATE_SUBSHELL_SCLOCKADJ_PID" = "" ]; then
      return 0
   fi

   local pid_still_running
   pid_still_running="0"
   kill -0 "$SDWDATE_SUBSHELL_SCLOCKADJ_PID" || { pid_still_running="$?" ; true; };

   if [ "$pid_still_running" = "0" ]; then
      sdwdate_log "$FUNCNAME: subshell for sclockadj with pid $SDWDATE_SUBSHELL_SCLOCKADJ_PID still running. Terminating..."
      kill -sigterm "$SDWDATE_SUBSHELL_SCLOCKADJ_PID" || true
      wait "$SDWDATE_SUBSHELL_SCLOCKADJ_PID"
      sdwdate_log "$FUNCNAME: subshell for sclockadj with pid $SDWDATE_SUBSHELL_SCLOCKADJ_PID Terminated."
      SDWDATE_SUBSHELL_SCLOCKADJ_PID=""
   else
      local SDWDATE_SUBSHELL_SCLOCKADJ_EXIT_CODE
      SDWDATE_SUBSHELL_SCLOCKADJ_EXIT_CODE="0"
      wait "$SDWDATE_SUBSHELL_SCLOCKADJ_PID" || { SDWDATE_SUBSHELL_SCLOCKADJ_EXIT_CODE="$?" ; true; };
      sdwdate_log "$FUNCNAME: subshell for sclockadj with pid $SDWDATE_SUBSHELL_SCLOCKADJ_PID no longer running. Exit code: $SDWDATE_SUBSHELL_SCLOCKADJ_EXIT_CODE"
      SDWDATE_SUBSHELL_SCLOCKADJ_PID=""
      if [ ! "$SDWDATE_SUBSHELL_SCLOCKADJ_EXIT_CODE" = "0" ]; then
         sdwdate_error_handler "subshell for sclockadj exited with non-zero exit code: $SDWDATE_SUBSHELL_SCLOCKADJ_EXIT_CODE"
      fi
   fi
}

sdwdate_set_time_using_sclockadj() {
   trap "sdwdate_error_handler" ERR

   sdwdate_terminate_sclockadj

   ## sets: NANOSECONDS
   ## sets: PLUS_OR_MINUS
   sdwdate_generate_nanoseconds

   local SDWDATE_MOVE_TIME_NANOSECONDS_TOTAL
   true "SDWDATE_MOVE_TIME_NANOSECONDS_TOTAL="\$\(\( $SDWDATE_MEDIAN_TIME_NANOSECONDS $PLUS_OR_MINUS $NANOSECONDS \)\)""
   SDWDATE_MOVE_TIME_NANOSECONDS_TOTAL="$(( $SDWDATE_MEDIAN_TIME_NANOSECONDS $PLUS_OR_MINUS $NANOSECONDS ))"

   local first_char
   first_char=${SDWDATE_MOVE_TIME_NANOSECONDS_TOTAL::1}

   local sclockadj_add_or_subtract
   if [ "$first_char" = "-" ]; then
      local SDWDATE_MOVE_TIME_NANOSECONDS_TOTAL_WITHOUT_SIGN
      SDWDATE_MOVE_TIME_NANOSECONDS_TOTAL_WITHOUT_SIGN="${SDWDATE_MOVE_TIME_NANOSECONDS_TOTAL#?}"
      sclockadj_add_or_subtract="--subtract $SDWDATE_MOVE_TIME_NANOSECONDS_TOTAL_WITHOUT_SIGN"
   else
      sclockadj_add_or_subtract="--add $SDWDATE_MOVE_TIME_NANOSECONDS_TOTAL"
   fi

   local SDWDATE_SCLOCKADJ_COMMAND
   ## There is an exception in /etc/sudoers.d/.
   SDWDATE_SCLOCKADJ_COMMAND="\
      sudo /usr/lib/sclockadj \
         $SDWDATE_SCLOCKADJ_VERBOSE \
         $SDWDATE_SCLOCKADJ_CHANGE_DATE \
         $SDWDATE_SCLOCKADJ_FIRST_WAIT \
         $SDWDATE_SCLOCKADJ_SYSTOHC \
         --move-min $SDWDATE_SCLOCKADJ_MOVE_MIN \
         --move-max $SDWDATE_SCLOCKADJ_MOVE_MAX \
         --wait-min $SDWDATE_SCLOCKADJ_WAIT_MIN \
         --wait-max $SDWDATE_SCLOCKADJ_WAIT_MAX \
         $sclockadj_add_or_subtract \
   "

   sdwdate_log "Launching into background: $SDWDATE_SCLOCKADJ_COMMAND"

   sclockadj_subshell_fifo="$TEMP_DIR/sclockadj.sclockadj_subshell_fifo"
   rm --force "$sclockadj_subshell_fifo"
   mkfifo "$sclockadj_subshell_fifo"

   {
      sdwdate_subshell_time_start() {
         SDWDATE_SUBSHELL_SCLOCKADJ_TIME_START="$(date +%s)"
         local SDWDATE_NEW_UNIXTIME_AND_NANOSECONDS_BEFORE_SETTING
         SDWDATE_NEW_UNIXTIME_AND_NANOSECONDS_BEFORE_SETTING="$(date +%s.%N)"
         local SDWDATE_NEW_DATE_BEFORE_SETTING
         SDWDATE_NEW_DATE_BEFORE_SETTING="$(date)"
         echo "Time before running sclockadj: $SDWDATE_NEW_UNIXTIME_AND_NANOSECONDS_BEFORE_SETTING [$SDWDATE_NEW_DATE_BEFORE_SETTING]"
      }

      sdwdate_subshell_time_end() {
         SDWDATE_SUBSHELL_SCLOCKADJ_TIME_END="$(date +%s)"
         true "SDWDATE_SUBSHELL_SCLOCKADJ_TOOK_TIME_SECONDS="\$\(\( $SDWDATE_SUBSHELL_SCLOCKADJ_TIME_END - $SDWDATE_SUBSHELL_SCLOCKADJ_TIME_START \)\)""
         SDWDATE_SUBSHELL_SCLOCKADJ_TOOK_TIME_SECONDS="$(( $SDWDATE_SUBSHELL_SCLOCKADJ_TIME_END - $SDWDATE_SUBSHELL_SCLOCKADJ_TIME_START ))"
         SDWDATE_SUBSHELL_SCLOCKADJ_TOOK_TIME_MINUTES="$(bc -l <<< "scale=2 ; $SDWDATE_SUBSHELL_SCLOCKADJ_TOOK_TIME_SECONDS / 60")"
         SDWDATE_SUBSHELL_SCLOCKADJ_TOOK_TIME_HOURS="$(bc -l <<< "scale=2 ; $SDWDATE_SUBSHELL_SCLOCKADJ_TOOK_TIME_MINUTES / 60")"
         ## Add leading zero.
         SDWDATE_SUBSHELL_SCLOCKADJ_TOOK_TIME_MINUTES="$(printf '%.2f\n' "$SDWDATE_SUBSHELL_SCLOCKADJ_TOOK_TIME_MINUTES")"
         SDWDATE_SUBSHELL_SCLOCKADJ_TOOK_TIME_HOURS="$(printf '%.2f\n' "$SDWDATE_SUBSHELL_SCLOCKADJ_TOOK_TIME_HOURS")"
         echo "was running for $SDWDATE_SUBSHELL_SCLOCKADJ_TOOK_TIME_SECONDS s [~ $SDWDATE_SUBSHELL_SCLOCKADJ_TOOK_TIME_MINUTES min] \
[~ $SDWDATE_SUBSHELL_SCLOCKADJ_TOOK_TIME_HOURS h]."
         unset SDWDATE_SUBSHELL_SCLOCKADJ_TIME_START
         unset SDWDATE_SUBSHELL_SCLOCKADJ_TIME_END
         unset SDWDATE_SUBSHELL_SCLOCKADJ_TOOK_TIME_SECONDS
         unset SDWDATE_SUBSHELL_SCLOCKADJ_TOOK_TIME_MINUTES
         unset SDWDATE_SUBSHELL_SCLOCKADJ_TOOK_TIME_HOURS
         local SDWDATE_NEW_UNIXTIME_AND_NANOSECONDS_AFTER_SETTING
         SDWDATE_NEW_UNIXTIME_AND_NANOSECONDS_AFTER_SETTING="$(date +%s.%N)"
         local SDWDATE_NEW_DATE_AFTER_SETTING
         SDWDATE_NEW_DATE_AFTER_SETTING="$(date)"
         echo "Time after running sclockadj: $SDWDATE_NEW_UNIXTIME_AND_NANOSECONDS_AFTER_SETTING [$SDWDATE_NEW_DATE_AFTER_SETTING]"
      }

      sdwdate_subshell_trap_sigterm() {
         if [ "$SDWDATE_SCLOCKADJ_COMMAND_PID" = "" ]; then
            sdwdate_subshell_time_end
            return 0
         fi
         ## There is a /etc/sudoers.d exception.
         echo "executing: sudo /usr/lib/sclockadj_kill_helper $SDWDATE_SCLOCKADJ_COMMAND_PID"
         sclockadj_kill_helper_output="$(sudo /usr/lib/sclockadj_kill_helper "$SDWDATE_SCLOCKADJ_COMMAND_PID" 2>&1)"
         echo "sclockadj_kill_helper_output: $sclockadj_kill_helper_output"
         unset sclockadj_kill_helper_output
         sdwdate_subshell_time_end
         exit 0
      }

      trap "sdwdate_subshell_trap_sigterm" SIGTERM

      sdwdate_subshell_time_start

      $SDWDATE_SCLOCKADJ_COMMAND 2>&1 &
      SDWDATE_SCLOCKADJ_COMMAND_PID="$!"

      SDWDATE_SCLOCKADJ_COMMAND_EXIT_CODE="0"
      wait "$SDWDATE_SCLOCKADJ_COMMAND_PID" || { SDWDATE_SCLOCKADJ_COMMAND_EXIT_CODE="$?" ; true; };

      sdwdate_subshell_time_end

      echo "exit code: $SDWDATE_SCLOCKADJ_COMMAND_EXIT_CODE"

      exit "$SDWDATE_SCLOCKADJ_COMMAND_EXIT_CODE"
   } > "$sclockadj_subshell_fifo" &

   SDWDATE_SUBSHELL_SCLOCKADJ_PID="$!"
   sdwdate_log "Started subshell for sclockadj with pid: $SDWDATE_SUBSHELL_SCLOCKADJ_PID"

   while read -r line; do
      sdwdate_log "sclockadj reports: $line"
   done < "$sclockadj_subshell_fifo" &
}

sdwdate_maybe_set_new_time() {
   trap "sdwdate_error_handler" ERR

   if [ "$DONT_SET_DATE" = "1" ]; then
      return
   fi

   ## Do not needlessly try to change time, when there is no difference.
   if [ "$SDWDATE_MEDIAN_TIME_SECONDS" = "0" ]; then
      sdwdate_log "No need to set clock."
      return 0
   fi

   if [ "$NO_MOVE_FORWARD" = "1" ]; then
      if [ "$SDWDATE_MEDIAN_TIME_SECONDS" -gt "0" ]; then
         sdwdate_log "Not setting clock forward."
         return 0
      fi
   fi

   if [ "$NO_MOVE_BACKWARDS" = "1" ]; then
      if [ "$SDWDATE_MEDIAN_TIME_SECONDS" -lt "0" ]; then
         sdwdate_log "Not setting clock backwards."
         return 0
      fi
   fi

   if [ "$SDW_MODE" = "startup" ]; then
      if [ "$SDWDATE_USE_SCLOCKADJ_WHEN_STARTUP" = "1" ]; then
         sdwdate_set_time_using_sclockadj
      else
         sdwdate_set_time_using_date
      fi
   elif [ "$SDW_MODE" = "daemon" ]; then
      if [ "$SDWDATE_USE_SCLOCKADJ_WHEN_DAEMON" = "1" ]; then
         sdwdate_set_time_using_sclockadj
      else
         sdwdate_set_time_using_date
      fi
   else
      sdwdate_error_handler 'SDW_MODE is neither "startup" nor "daemon".'
   fi
}

sdwdate_dispatcher_prerequisite() {
   trap "sdwdate_error_handler" ERR

   if [ "$DISPATCH_PREREQUISITE" = "" ]; then
      true "DISPATCH_PREREQUISITE is empty, skipping."
   else
      while true; do
         sdwdate_no_duplicate_log "dispatching prerequisite (SDW_MODE: $SDW_MODE) (CURL: $CURL) (LD_PRELOAD: $LD_PRELOAD): $DISPATCH_PREREQUISITE"

         local prerequisite_exit_code
         prerequisite_exit_code="0"
         prerequisite_output="$(eval $DISPATCH_PREREQUISITE 2>&1)" || { prerequisite_exit_code="${PIPESTATUS[0]}" ; true; };

         true "prerequisite_exit_code: $prerequisite_exit_code"
         true "prerequisite_output: $prerequisite_output"

         if [ "$prerequisite_exit_code" = "0" ]; then
            ## Ok.
            sdwdate_log "DISPATCH_PREREQUISITE exited $prerequisite_exit_code, continuing..."
            break
         elif [ "$prerequisite_exit_code" = "1" ]; then
            ## Error.
            sdwdate_error_handler "DISPATCH_PREREQUISITE exited $prerequisite_exit_code | $prerequisite_output | requested explicit exiting..."
         elif [ "$prerequisite_exit_code" = "2" ]; then
            ## Wait.
            sdwdate_no_duplicate_log "DISPATCH_PREREQUISITE exited $prerequisite_exit_code | $prerequisite_output | waiting..."
            sleep 10 &
            sleep_pid="$!"
            wait "$sleep_pid" || true
            unset sleep_pid
         else
            ## Unexpected error.
            sdwdate_error_handler "DISPATCH_PREREQUISITE exited $DISPATCH_PREREQUISITE, neither 0, 1, or 2. | $prerequisite_output | unexpected error, exiting..."
         fi

      done
   fi
}

sdwdate_dispatcher_pre() {
   trap "sdwdate_error_handler" ERR

   if [ "$DISPATCH_PRE" = "" ]; then
      true "DISPATCH_PRE is empty, skipping."
   else
      sdwdate_no_duplicate_log "dispatching pre (SDW_MODE: $SDW_MODE): $DISPATCH_PRE"
      eval $DISPATCH_PRE
   fi
}

sdwdate_failed() {
   trap "sdwdate_error_handler" ERR

   rm --force "$SUCCESS_FILE"
   touch "$DONE_FILE"
}

sdwdate_success() {
   trap "sdwdate_error_handler" ERR

   touch "$SUCCESS_FILE"
   touch "$DONE_FILE"
}

sdwdate_dispatcher_post_success() {
   trap "sdwdate_error_handler" ERR

   if [ "$DISPATCH_POST_SUCCESS" = "" ]; then
      true "DISPATCH_POST_SUCCESS is empty, skipping."
   else
      sdwdate_no_duplicate_log "dispatching post_success (SDW_MODE: $SDW_MODE): $DISPATCH_POST_SUCCESS"
      eval $DISPATCH_POST_SUCCESS
   fi
}

sdwdate_dispatcher_post_failure() {
   trap "sdwdate_error_handler" ERR

   if [ "$DISPATCH_POST_FAILURE" = "" ]; then
      true "DISPATCH_POST_FAILURE is empty, skipping."
   else
      sdwdate_no_duplicate_log "dispatching post_failure (SDW_MODE: $SDW_MODE): $DISPATCH_POST_FAILURE"
      eval $DISPATCH_POST_FAILURE
   fi
}

sdwdate_error_test() {
   trap "sdwdate_error_handler" ERR
   if [ -f "/var/lib/sdw_error" ]; then
      sdwdate_error_handler "Test file /var/lib/sdw_error to force test an error exists."
      sleep 10 &
      sleep_pid="$!"
      wait "$sleep_pid" || true
      unset sleep_pid
   fi
}

sdwdate_sleep() {
   trap "sdwdate_error_handler" ERR
   ## INTERVAL: in minutes
   ## sleep: in seconds

   echo "RANDOMIZE: $RANDOMIZE"

   local minutes
   if [ "$RANDOMIZE" = "1" ]; then
      test -e "/dev/random"
      minutes="$(( ($(od -An -N2 -i "/dev/random") )%($INTERVAL) ))"
      if [ "$MIN_INTERVAL" -ge "$minutes" ]; then
         true "minutes="\$\(\( $minutes + $MIN_INTERVAL \)\)""
         minutes="$(( $minutes + $MIN_INTERVAL ))"
      fi
   else
      minutes="$INTERVAL"
   fi

   local seconds
   true "seconds="\$\(\( $minutes \* 60 \)\)""
   seconds="$(( $minutes * 60 ))"

   sdwdate_log "Sleeping for $minutes minutes."

   sleep "$seconds" &
   sleep_pid="$!"
   wait "$sleep_pid" || true
   unset sleep_pid
}

sdwdate_maybe_read_config_folder() {
   trap "sdwdate_error_handler" ERR
   local grep_exit_code
   grep_exit_code="$?"
   echo "${1+"$@"}" | grep --quiet "\-\-noconfig" || { grep_exit_code="$?" ; true; };
   if [ "$grep_exit_code" = "0" ]; then
      true "Found --noconfig, skip reading config folder."
   else
      ## Not found, let's read config folder.
      sdwdate_read_config_folder
   fi
}

sdwdate_maybe_parse_cmd_options() {
   trap "sdwdate_error_handler" ERR
   if [ "$PARSE_CMD_ONLY_ON_STARTUP" = "1" ]; then
      if [ "$ALREADY_PARSED_CDM_ON_STARTUP" = "1" ]; then
         true "ALREADY_PARSED_CDM_ON_STARTUP is 1, not parsing cmd options again."
      else
         ALREADY_PARSED_CDM_ON_STARTUP="1"
         sdwdate_parse_cmd_options
      fi
   else
      sdwdate_parse_cmd_options ${1+"$@"}
   fi
}

sdwdate_maybe_sleep_or_exit() {
   trap "sdwdate_error_handler" ERR
   ## Check, if we are running in daemon mode.
   if [ "$INTERVAL" = "" ] || [ "$INTERVAL" = "0" ]; then
      ## No daemon mode.
      exit 0
   else
      ## Daemon mode.
      SDW_MODE="daemon"
      sdwdate_sleep
   fi
}

sdwdate_main() {
   trap "sdwdate_error_handler" ERR

   sdwdate_log "sdwdate_main..."

   sdwdate_sanity_tests

   while true; do
      sdwdate_log "Running sdwdate..."

      sdwdate_maybe_read_config_folder ${1+"$@"}
      sdwdate_maybe_parse_cmd_options ${1+"$@"}
      sdwdate_defaults
      sdwdate_preparation
      if [ "$DEBUG" = "1" ]; then
         sdwdate_enable_debugging
      fi

      sdwdate_error_test

      sdwdate_dispatcher_pre
      sdwdate_dispatcher_prerequisite

      sdwdate_pick

      ## Do not continue, if an error was caught.
      if [ ! "$sdwdate_loop_return" = "0" ]; then
         sdwdate_failed
         sdwdate_dispatcher_post_failure
      else
         sdwdate_build_median
         sdwdate_maybe_set_new_time
         sdwdate_success
         sdwdate_dispatcher_post_success
      fi

      sdwdate_maybe_sleep_or_exit
   done
}

sdwdate_log "Loaded. | pid: $$ | LD_PRELOAD: $LD_PRELOAD"

sdwdate_main ${1+"$@"}

sdwdate_log "End."
